"use strict";(self["webpackChunkGPCPAMM"]=self["webpackChunkGPCPAMM"]||[]).push([[141],{2141:function(t,e,i){i.d(e,{ck:function(){return F},g5:function(){return M}});var n=i(3526),r=i(6212),s=i(7033),l=i(8081);const a=BigInt(-1),u=BigInt(0),o=BigInt(1),h=BigInt(5),c={};let d="0000";while(d.length<80)d+=d;function f(t){let e=d;while(e.length<t)e+=e;return BigInt("1"+e.substring(0,t))}function m(t,e,i){const r=BigInt(e.width);if(e.signed){const e=o<<r-o;(0,n.vA)(null==i||t>=-e&&t<e,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:t}),t=t>u?(0,s.ST)((0,s.dK)(t,r),r):-(0,s.ST)((0,s.dK)(-t,r),r)}else{const e=o<<r;(0,n.vA)(null==i||t>=0&&t<e,"overflow","NUMERIC_FAULT",{operation:i,fault:"overflow",value:t}),t=(t%e+e)%e&e-o}return t}function v(t){"number"===typeof t&&(t=`fixed128x${t}`);let e=!0,i=128,r=18;if("string"===typeof t)if("fixed"===t);else if("ufixed"===t)e=!1;else{const s=t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);(0,n.MR)(s,"invalid fixed format","format",t),e="u"!==s[1],i=parseInt(s[2]),r=parseInt(s[3])}else if(t){const s=t,l=(t,e,i)=>null==s[t]?i:((0,n.MR)(typeof s[t]===e,"invalid fixed format ("+t+" not "+e+")","format."+t,s[t]),s[t]);e=l("signed","boolean",e),i=l("width","number",i),r=l("decimals","number",r)}(0,n.MR)(i%8===0,"invalid FixedNumber width (not byte aligned)","format.width",i),(0,n.MR)(r<=80,"invalid FixedNumber decimals (too large)","format.decimals",r);const s=(e?"":"u")+"fixed"+String(i)+"x"+String(r);return{signed:e,width:i,decimals:r,name:s}}function g(t,e){let i="";t<u&&(i="-",t*=a);let n=t.toString();if(0===e)return i+n;while(n.length<=e)n=d+n;const r=n.length-e;n=n.substring(0,r)+"."+n.substring(r);while("0"===n[0]&&"."!==n[1])n=n.substring(1);while("0"===n[n.length-1]&&"."!==n[n.length-2])n=n.substring(0,n.length-1);return i+n}class w{format;#t;#e;#i;_value;constructor(t,e,i){(0,n.gk)(t,c,"FixedNumber"),this.#e=e,this.#t=i;const r=g(e,i.decimals);(0,l.n)(this,{format:i.name,_value:r}),this.#i=f(i.decimals)}get signed(){return this.#t.signed}get width(){return this.#t.width}get decimals(){return this.#t.decimals}get value(){return this.#e}#n(t){(0,n.MR)(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)}#r(t,e){return t=m(t,this.#t,e),new w(c,t,this.#t)}#s(t,e){return this.#n(t),this.#r(this.#e+t.#e,e)}addUnsafe(t){return this.#s(t)}add(t){return this.#s(t,"add")}#l(t,e){return this.#n(t),this.#r(this.#e-t.#e,e)}subUnsafe(t){return this.#l(t)}sub(t){return this.#l(t,"sub")}#a(t,e){return this.#n(t),this.#r(this.#e*t.#e/this.#i,e)}mulUnsafe(t){return this.#a(t)}mul(t){return this.#a(t,"mul")}mulSignal(t){this.#n(t);const e=this.#e*t.#e;return(0,n.vA)(e%this.#i===u,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),this.#r(e/this.#i,"mulSignal")}#u(t,e){return(0,n.vA)(t.#e!==u,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#n(t),this.#r(this.#e*this.#i/t.#e,e)}divUnsafe(t){return this.#u(t)}div(t){return this.#u(t,"div")}divSignal(t){(0,n.vA)(t.#e!==u,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#n(t);const e=this.#e*this.#i;return(0,n.vA)(e%t.#e===u,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),this.#r(e/t.#e,"divSignal")}cmp(t){let e=this.value,i=t.value;const n=this.decimals-t.decimals;return n>0?i*=f(n):n<0&&(e*=f(-n)),e<i?-1:e>i?1:0}eq(t){return 0===this.cmp(t)}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=this.#e;return this.#e<u&&(t-=this.#i-o),t=this.#e/this.#i*this.#i,this.#r(t,"floor")}ceiling(){let t=this.#e;return this.#e>u&&(t+=this.#i-o),t=this.#e/this.#i*this.#i,this.#r(t,"ceiling")}round(t){if(null==t&&(t=0),t>=this.decimals)return this;const e=this.decimals-t,i=h*f(e-1);let n=this.value+i;const r=f(e);return n=n/r*r,m(n,this.#t,"round"),new w(c,n,this.#t)}isZero(){return this.#e===u}isNegative(){return this.#e<u}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return w.fromString(this.toString(),t)}static fromValue(t,e,i){const r=null==e?0:(0,s.WZ)(e),l=v(i);let a=(0,s.Ab)(t,"value");const o=r-l.decimals;if(o>0){const e=f(o);(0,n.vA)(a%e===u,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),a/=e}else o<0&&(a*=f(-o));return m(a,l,"fromValue"),new w(c,a,l)}static fromString(t,e){const i=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);(0,n.MR)(i&&i[2].length+i[3].length>0,"invalid FixedNumber string value","value",t);const r=v(e);let s=i[2]||"0",l=i[3]||"";while(l.length<r.decimals)l+=d;(0,n.vA)(l.substring(r.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),l=l.substring(0,r.decimals);const a=BigInt(i[1]+s+l);return m(a,r,"fromString"),new w(c,a,r)}static fromBytes(t,e){let i=(0,s.Dg)((0,r.q5)(t,"value"));const n=v(e);return n.signed&&(i=(0,s.ST)(i,n.width)),m(i,n,"fromBytes"),new w(c,i,n)}}const b=["wei","kwei","mwei","gwei","szabo","finney","ether"];function p(t,e){let i=18;if("string"===typeof e){const t=b.indexOf(e);(0,n.MR)(t>=0,"invalid unit","unit",e),i=3*t}else null!=e&&(i=(0,s.WZ)(e,"unit"));return w.fromValue(t,i,{decimals:i,width:512}).toString()}function k(t,e){(0,n.MR)("string"===typeof t,"value must be a string","value",t);let i=18;if("string"===typeof e){const t=b.indexOf(e);(0,n.MR)(t>=0,"invalid unit","unit",e),i=3*t}else null!=e&&(i=(0,s.WZ)(e,"unit"));return w.fromString(t,{decimals:i,width:512}).value}function F(t){return p(t,18)}function M(t){return k(t,18)}}}]);